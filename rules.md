# 프로그래밍 핵심 규칙 (RULE.md)

## 🎯 핵심 철학

### 우선순위 원칙
```
실용성 > 이론적 완벽성
단순함 > 복잡함
명확성 > 간결성
테스트 가능성 > 성능 최적화
점진적 개선 > 빅뱅 변경
```

## ⚡ 즉시 적용 규칙

### 1. 아키텍처 경계 설정
- **DTO/엔티티 분리**: API 스키마와 도메인 모델은 별도 관리
- **레이어 의존성**: Domain → Application → API → Infrastructure (역방향 금지)
- **포트/어댑터 패턴**: 비즈니스 로직은 인터페이스에 의존, 구현체는 인프라 레이어에

### 2. 테스트 우선 개발
- **TDD 사이클**: Red(실패 테스트) → Green(최소 구현) → Refactor(개선)
- **테스트 피라미드(가이드)**: 단위 70% / 통합 20% / E2E 10%를 권장하되 팀/시스템에 맞게 조정
- **회귀 방지**: 기존 코드 수정 시 먼저 테스트 추가

### 3. 코드 품질 기준
- **함수 크기**: 기본 가이드 20줄 내외, 인수 3개 이하(알고리즘/IO 경계부 등 예외 허용)
- **단일 책임**: 하나의 함수/클래스는 하나의 변경 이유만 가짐
- **명명 규칙**: 의도를 명확히 드러내는 이름 (검색 가능, 일관된 어휘)

## 🏗️ 설계 원칙

### SOLID 원칙 (필수)
```python
# S - 단일 책임
class UserService:  # 사용자 관리만 담당
    def create_user(): ...
    # ❌ def send_email(): ...  # 이메일은 별도 서비스로

# O - 개방-폐쇄
class PaymentProcessor:
    def process(payment: Payment): ...  # 인터페이스에 의존
    # 새 결제수단 추가 시 기존 코드 수정 없이 새 클래스 추가

# L - 리스코프 치환
# 하위 타입은 상위 타입을 완전히 대체 가능해야 함

# I - 인터페이스 분리
class Printable: ...
class Scannable: ...
# ❌ class MultiFunctionDevice: ...  # 너무 큰 인터페이스

# D - 의존관계 역전
class ReportGenerator:
    def __init__(self, reader: DataReader): ...  # 추상화에 의존
    # ❌ def __init__(self, db: DatabaseReader): ...  # 구체 클래스 의존
```

### 실용적 원칙
- **KISS**: 가능한 한 단순하게 (불필요한 복잡성 제거)
- **DRY**: 중복 제거 (모든 지식은 시스템에서 단 한 번만)
- **YAGNI**: 미래를 위한 과도한 일반화 금지 (필요할 때 구현)
- **명확성 우선**: 간결성보다 가독성과 의도 전달을 우선(세부 설명은 주석/문서로 분리)

## 🔄 점진적 전환 전략

### Clean Architecture 도입 (단계별)
```yaml
Phase 0: # 즉시 적용 (코드 이동 없이)
  - DTO/엔티티 분리 선언
  - 테스트 게이트 추가
  - import-linter로 경계 검증

Phase 1: # 샘플 경로 전환
  - 한 기능 선택하여 유스케이스 분리
  - 포트 정의 및 리포지토리 추출
  - 단위 테스트로 검증

Phase 2: # 확산
  - 새 기능은 100% 클린 경로로
  - 레거시는 Adapter로 감싸기
  - 읽기 분리(CQRS 부분 적용): 복잡한 조회는 Query 핸들러/읽기 전용 포트로 분리
  - 점진적 마이그레이션

Phase 3: # 인프라 끊어내기 (DB/외부 API)
  - UoW(단위 작업): 유스케이스가 트랜잭션 경계를 명확히 엶 (예: with uow:)
  - Outbox 패턴: 도메인 이벤트→Outbox 테이블→비동기 발행 워커로 최종 전달
  - 안전한 마이그레이션: add nullable → backfill → make non-null → 제거(2+ 릴리스 분할)
```

### 3단계: 인프라 끊어내기 원칙
- 유스케이스는 UoW를 통해 트랜잭션 경계를 제어하고, 인프라 세부사항은 포트/어댑터로 캡슐화한다.
- 도메인 이벤트는 Outbox로 내보내고 별도 워커에서 외부 발행(재시도/멱등성 확보).
- 스키마 변경은 가역적 단계로 분할하고 각 단계 사이에 배포와 모니터링을 둔다.

## 📝 개발 워크플로우

### 애자일 실천법
- **사용자 스토리**: "<사용자>로서 <목표>를 위해 <기능>을 원한다"
- **INVEST 기준**: Independent, Negotiable, Valuable, Estimable, Small, Testable
- **준비 정의(DoR)**: 명확한 수용기준, 테스트 가능성, 비즈니스 가치가 확인되면 ‘준비 완료’
- **정의 완료(DoD)**: 코드 완성 + 테스트 통과 + 문서화 + 리뷰 완료

### CI/CD 파이프라인
```yaml
CI: # 지속적 통합
  1. 코드 커밋
  2. 자동 빌드
  3. 단위 테스트
  4. 정적 분석 (SAST)
  5. 통합 테스트

CD: # 지속적 배포
  6. 스테이징 배포
  7. E2E 테스트
  8. 카나리 릴리즈 (1% → 10% → 100%)
  9. 모니터링 & 롤백 준비
```

### 아키텍처 계약/CI 게이트(실행·강제)
- 단위 테스트 게이트: `pytest -m "unit"` 통과 전 통합/E2E 실행 금지(Fail Fast).
- import-linter: 초기에 경고로 운영, 2주 뒤 위반 시 CI 실패로 승격.
- 코드 생성 산출물 드리프트 방지: `gen:api` 실행 후 변경 감지 시 실패.

예시: `.importlinter` 최소 계약
```ini
[importlinter]
root_package = .

[contract:layers]
name = Clean Layers
layers =
    core.domain
    core.application
    api
    infra
containers =
    core.domain -> core.application -> api -> infra

[contract:forbidden]
name = No framework in domain
source_modules =
    core.domain
forbidden_modules =
    fastapi
    pydantic
    sqlalchemy
```

### ADR(Architecture Decision Record)
- 주요 아키텍처/스키마/운영 결정은 `docs/adr/YYYYMMDD-<slug>.md`로 기록(배경/결정/대안/영향/후속조치).

## 🛡️ 보안 원칙

### 기본 보안 규칙
- **최소 권한**: 필요한 최소한의 권한만 부여 (PoLP)
- **제로 트러스트**: 모든 접근 검증 (내부 네트워크도 신뢰 안함)
- **입력 검증**: 모든 외부 입력 화이트리스트 검증
- **출력 인코딩**: XSS 방지를 위한 HTML 인코딩

### DevSecOps 실천
```yaml
Design: 위협 모델링 (STRIDE)
Develop: 시큐어 코딩, SAST
Test: DAST, 모의 해킹
Deploy: 취약점 스캔
Monitor: 실시간 보안 모니터링
```

### DevSecOps 체크리스트(공급망/비밀 관리)
- SCA(의존성 취약점) 스캔과 SBOM 생성/서빙을 CI에 통합.
- 컨테이너 이미지 스캔(베이스 이미지 취약점 포함) 및 서명 검증.
- Secrets 스캔(커밋/PR 모두)과 비밀 관리 시스템 연동(환경변수/볼트).
- 서드파티 라이선스 검토와 정책 위반 차단.

## 📊 품질 지표

### 측정 가능한 목표
- **코드 커버리지**: 단위 테스트 80% 이상
- **복잡도**: 순환 복잡도 10 이하
- **기술 부채**: 총 코드의 5% 이하
- **빌드 시간**: 5분 이내
- **배포 빈도**: 일 1회 이상

### SRE 4대 골든 시그널
1. **Latency**: 응답 시간 (p95 < 500ms)
2. **Traffic**: 초당 요청 수
3. **Errors**: 오류율 (< 0.1%)
4. **Saturation**: 자원 사용률 (< 80%)

### 운영/관측(Observability)
- Logs/Metrics/Traces 3종을 설계 단계부터 수집하고, 요청 상관관계 ID(Trace/Span ID)를 전 구간 전파.
- 필수 대시보드(성능/오류/자원)와 경보 기준을 정의하고 코드/인프라 변경 시 함께 갱신.

### Resilience(탄력성) 기본 규칙
- 모든 외부 호출은 타임아웃 필수, 멱등 작업에 한해 지수 백오프 재시도 적용.
- 서킷 브레이커와 벌크헤드로 장애 전파를 차단하고, 폴백 전략을 사전에 정의.

## 🚨 위험 관리

### 점진적 마이그레이션
- **Feature Flag**: 새 기능 단계적 활성화
- **병렬 운영**: 기존/신규 경로 동시 운영 후 전환
- **롤백 계획**: 모든 변경에 대한 즉시 복구 방안

### 언제 멈출 것인가?
- 도메인 규칙이 매우 단순한 CRUD 수준
- 팀 규모가 작고 변경이 드문 경우
- 배포 환경이 제한적인 경우
→ 최소한의 테스트와 문서화만 유지

## 💡 핵심 요약

```yaml
즉시 실천:
  - 테스트 먼저 작성
  - 함수는 20줄 내외(필요 시 예외)
  - 모든 입력 검증
  - 코드 리뷰 필수

점진적 개선:
  - 새 기능부터 클린 아키텍처
  - 레거시는 어댑터로 감싸기
  - 측정하고 개선하기
  
절대 금지:
  - 빅뱅 리팩토링
  - 테스트 없는 배포
  - 하드코딩된 설정값
  - 문서 없는 API
```

---
*이 규칙들은 실무 검증된 원칙들의 최소 집합입니다. 프로젝트 특성에 맞게 조정하되, 핵심 원칙은 유지하세요.*
